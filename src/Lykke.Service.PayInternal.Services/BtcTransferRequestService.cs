using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using Common.Log;
using Lykke.Bitcoin.Api.Client.AutoGenerated.Models;
using Lykke.Bitcoin.Api.Client.BitcoinApi;
using Lykke.Bitcoin.Api.Client.BitcoinApi.Models;
using Lykke.Service.PayInternal.Core.Domain.Transfer;
using Lykke.Service.PayInternal.Core.Domain.Wallet;
using Lykke.Service.PayInternal.Core.Services;
using Lykke.Service.PayInternal.Services.Domain;
using NBitcoin;
using Newtonsoft.Json;

namespace Lykke.Service.PayInternal.Services
{
    public class BtcTransferRequestService : ITransferRequestService
    {
        private const string BitcoinAsset = "BTC";
        private readonly ITransferRepository _transferRepository;
        private readonly IWalletRepository _walletRepository;
        private readonly IBitcoinApiClient _bitcointApiClient;
        private readonly ILog _log;

        #region .ctors
        public BtcTransferRequestService(
            ITransferRepository transferRepository,
            IWalletRepository walletRepository,
            IBitcoinApiClient bitcointApiClient,
            ILog log)
        {
            _transferRepository = transferRepository ?? throw new ArgumentNullException(nameof(transferRepository));
            _walletRepository = walletRepository ?? throw new ArgumentNullException(nameof(walletRepository));
            _bitcointApiClient = bitcointApiClient ?? throw new ArgumentNullException(nameof(bitcointApiClient));
            _log = log ?? throw new ArgumentNullException(nameof(log));
        }
        #endregion
        #region public
        public async Task<ITransferRequest> CreateTransferAsync(ITransferRequest transferRequest)
        {
            var wallets = (await _walletRepository.GetByMerchantAsync(transferRequest.MerchantId)).ToList();
            var transactions = new List<ITransactionRequest>();

            foreach (var transaction in transferRequest.TransactionRequests)
            {
                List<ISourceAmount> sources = new List<ISourceAmount>();
                if (transaction.SourceAmounts == null || !transaction.SourceAmounts.Any())
                {
                    sources.AddRange(CalculateSources(
                        from w in wallets
                        select new SourceAmount
                        {
                            SourceAddress = w.Address,
                            Amount = 0
                        }, 0, wallets));
                }
                else
                {
                    sources.AddRange(CalculateSources(transaction.SourceAmounts, 0, wallets));
                }

                if (!sources.Any())
                {
                    await _log.WriteWarningAsync(nameof(BtcTransferRequestService), nameof(CreateTransferAsync),
                        JsonConvert.SerializeObject(transferRequest),
                        "Source addresses don't found or amount is not enought.");
                    return BtcTransferRequest.CreateErrorTransferRequest(transferRequest.MerchantId,
                        TransferStatusError.InvalidAmount, transferRequest.TransactionRequests);
                }
                var transferWallets = new List<string>(sources.Select(s => s.SourceAddress))
                {
                    transaction.DestinationAddress
                };

                var isAddressesValid = CheckAddressesValid(transferWallets);
                if (!isAddressesValid)
                {
                    await _log.WriteWarningAsync(nameof(BtcTransferRequestService), nameof(CreateTransferAsync),
                        JsonConvert.SerializeObject(transferRequest),
                        "Source addresses don't found or amount is not enought.");
                    return BtcTransferRequest.CreateErrorTransferRequest(transferRequest.MerchantId,
                        TransferStatusError.InvalidAddress, transferRequest.TransactionRequests);
                }
                var result = await CreateBtcTransfer(sources, transaction.DestinationAddress);
                if (result.Item2 != TransferStatusError.NotError)
                {
                    await _log.WriteWarningAsync(nameof(BtcTransferRequestService), nameof(CreateTransferAsync),
                        JsonConvert.SerializeObject(transferRequest),
                        "Create transfer error occurs.");
                    return BtcTransferRequest.CreateErrorTransferRequest(transferRequest.MerchantId,
                        result.Item2, transferRequest.TransactionRequests);
                }
                transactions.Add(result.Item1);
            }

            return BtcTransferRequest.CreateTransferRequest(transferRequest.MerchantId, transactions);

        }



        public async Task<ITransferRequest> UpdateTransferStatusAsync(ITransferRequest transfer)
        {
            var t = await GetTransferInfoAsync(transfer);
            if (t == null)
            {
                return null;
            }
            t.TransferStatus = transfer.TransferStatus;
            t.TransferStatusError = transfer.TransferStatusError;
            return await _transferRepository.SaveAsync(t);
        }



        public async Task<ITransferRequest> UpdateTransferAsync(ITransferRequest transfer)
        {
            return await _transferRepository.SaveAsync(transfer);
        }

        public async Task<ITransferRequest> GetTransferInfoAsync(ITransferRequest transfer)
        {
            return await _transferRepository.GetAsync(transfer.TransferId);
        }
        #endregion
        #region private

        private async Task<Tuple<ITransactionRequest, TransferStatusError>> CreateBtcTransfer(List<ISourceAmount> sources, string destination)
        {
            sources = sources.Where(s => s.Amount > 0).ToList();
            OnchainResponse request = null;
            var result = new TransactionRequest
            {
                DestinationAddress = destination,
                Amount = sources.Sum(s => s.Amount),
                Currency = BitcoinAsset,
                SourceAmounts = sources,
                CountConfirm = 1
            };

            var store = new MultipleTransferRequest
            {
                Asset = BitcoinAsset,
                Destination = destination,
                Sources = (from s in sources
                           select new ToOneAddress(s.SourceAddress, s.Amount)).ToList()
            };

            if (sources.Any())
            {
                request = await _bitcointApiClient.TransactionMultipleTransfer(null, store.Destination, store.Asset, 0, 0, store.Sources);
            }


            if (request == null || request.HasError)
            {

                if (request?.Error?.ErrorCode == ErrorCode.NotEnoughBitcoinAvailable)
                {
                    var errorCode = request.Error.Code;
                    var errorMessage = request.Error.Message;
                    await _log.WriteWarningAsync(nameof(BtcTransferRequestService), nameof(CreateBtcTransfer), JsonConvert.SerializeObject(store), $"Invalid amount. Error on TransactionMultipletransfer: {errorMessage} ({errorCode})");

                    return new Tuple<ITransactionRequest, TransferStatusError>(result, TransferStatusError.InvalidAddress);
                }

                await _log.WriteWarningAsync(nameof(BtcTransferRequestService), nameof(CreateBtcTransfer), JsonConvert.SerializeObject(store), "Transaction not confirmed.");

                return new Tuple<ITransactionRequest, TransferStatusError>(result, TransferStatusError.NotConfirmed);
            }

            result.TransactionHash = request.Transaction.Hash;
            await _log.WriteInfoAsync(nameof(BtcTransferRequestService), nameof(CreateBtcTransfer), JsonConvert.SerializeObject(result), "Transfer created");

            return new Tuple<ITransactionRequest, TransferStatusError>(result, TransferStatusError.NotError);

        }

        private List<ISourceAmount> CalculateSources(IEnumerable<ISourceAmount> sources, decimal amount, List<IWallet> wallets)
        {
            var result = new List<ISourceAmount>();
            var sourcesList = sources?.ToList() ?? new List<ISourceAmount>();
            var sourceToCalc = new List<ISourceAmount>();
            if (sourcesList.Count == 0)
            {
                sourceToCalc.AddRange(from w in wallets
                                      select new SourceAmount { SourceAddress = w.Address, Amount = w.Amount });
            }
            else if (sourcesList.All(s => s.Amount == 0))
            {
                sourceToCalc.AddRange(from s in sourcesList
                                      join w in wallets on s.SourceAddress equals w.Address
                                      select new SourceAmount { SourceAddress = s.SourceAddress, Amount = w.Amount });
            }
            else
            {
                sourceToCalc.AddRange(from s in sourcesList
                                      join w in wallets on s.SourceAddress equals w.Address
                                      where s.Amount <= w.Amount
                                      select new SourceAmount { SourceAddress = s.SourceAddress, Amount = w.Amount });
                if (result.Count != sourcesList.Count)
                {
                    result.Clear();
                }
            }

            if (amount == 0)
            {
                result = sourceToCalc;
            }
            else
            {
                var amounToPay = amount;
                while (amounToPay > 0)
                {
                    var sourceAmount = sourceToCalc.FirstOrDefault();
                    if (sourceAmount == null)
                    {
                        return null;
                    }
                    if (amounToPay > sourceAmount.Amount)
                    {
                        amounToPay -= sourceAmount.Amount;
                    }
                    else
                    {
                        sourceAmount.Amount = amounToPay;
                        amounToPay = 0;
                    }
                    result.Add(sourceAmount);
                    sourceToCalc.Remove(sourceAmount);
                }
            }

            return result.Count == 0 ? null : result;
        }

        private bool CheckAddressesValid(IReadOnlyList<string> addresses)
        {
            try
            {
                foreach (var address in addresses)
                {
                    BitcoinAddress.Create(address);
                }
                return true;
            }
            catch
            {
                return false;
            }

        }
        #endregion
    }
}
